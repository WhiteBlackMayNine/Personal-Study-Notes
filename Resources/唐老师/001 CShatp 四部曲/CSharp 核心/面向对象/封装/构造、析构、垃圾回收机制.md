---
tags:
  - 科学/编程语言/Csharp/唐老狮/核心/面向对象/封装/构造、析构、垃圾回收机制
created: 2024-03-22
课时: "9"
来源: https://www.taikr.com/course/1139/task/35503/show
---

---
# 关联知识点

 [[Resources/唐老狮/CShatp 四部曲/CSharp 核心/面向对象/封装/类和对象|类和对象]]

---
# 知识点

## 构造函数

### 基本概念

- 在实例化对象时，会调用的用于初始化的函数
- 如果不写，默认存在一个无参构造函数
### 写法

- 没有返回值
- 函数名和类名必须相同
- 没有特殊要求时，一般都是 `public`
- 可以被重载
- `this` 指向当前调用该函数的对象自己
	- `this.age = age`
		- 前一个为类对象自己的`age`，后一个为传进来的参数
- 注意
	- 如果不自己实现无参构造函数而实现了有参构造函数，会失去默认的无参构造
	- **有参构造会顶掉无参构造**
## 构造函数的特殊写法

- 可以使用`this`重写构造函数代码
	- `访问修饰符 构造函数名(参数列表):this(参数1,参数2,……)`
		- 参数为其他构造函数的参数
		- 会先调用后面`this`的构造函数
			- 根据参数，跳转到对应的构造函数中
		- `this`内的参数可以是常量
## 析构函数（了解即可）

### 基本概念

- 但引用类型的堆内存被回收时，会调用该函数
	- 当垃圾真正被回收时，调用
- 对于需要手动管理内存的语言（C++），需要在析构函数中做一些内存回收处理
- 但 C# 中存在自动垃圾回收机制GC
- 所以几乎不会使用析构函数
- 除非想要在某一个对象被垃圾回收时，做一些特殊处理
### 基本语法

- `~类名(){ }`
- 注意
	- 在Unity开发中析构函数几乎不会被使用
## 垃圾回收机制

^923c51

### 理论知识（略）

- 垃圾回收，简称GC
- 过程是在遍历堆（Heep）上动态分配的对象
- 通过识别它们是否被引用来确定哪些是垃圾，哪些是被使用
- 所谓垃圾就是没有被任何变量，对象引用的内容
- 有很多种算法（略）
### 大概原理

- 0代内存 ， 1代内存 ， 2代内存
### 代的概念

- 代是垃圾回收机制使用的一种算法（分代算法）
- 新分别的对象都会被配置在第0代内存中
- 每次分配都可能会进行垃圾回收已释放内存（0代内存 满时）
- 在一次内存回收过程开始时，垃圾回收器会认为堆中全是垃圾，会进行以下两步
	- 标记对象，从根（静态字段、方法参数）开始检查引用对象，标记后为可达对象，未标记的为不可达对象，**不可达对象就认为是垃圾**
	- 搬迁对象压缩堆（挂起执行托管代码线程）释放未标记的对象，搬迁可达对象，修改引用地址
- 大对象总被认为是第2代内存，目的是减少性能消耗，提高性能
- 不会对大对象进行搬迁压缩，85000字节（83kb）以上的对象为大对象
### 手动触发垃圾回收的方法

- `GC.Collect();`
- 一般情况下不会频繁调用
- 都是在 Loading 过场景时才调用

---
# 总结

## 引用类型生命周期

- 引用类型生命周期
	- 出生在构造函数（new 一个构造函数） ，析构函数是它的死亡，垃圾回收时会死亡，内存满或手动调用GC时会触发垃圾回收

---

