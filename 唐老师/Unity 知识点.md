---
tags:
  - 科学/Unity/Unity小知识点
备注: 日积月累 厚积薄发
核心: 游戏是数据的一种表现
---

---
# 知识点

## Unity中打印信息的两种方式

- 没有继承MonoBehavior类的时候
	- `Debug.Log();`
- 继承了MonoBehavior有一个线程的方法可以使用
	- `print(1234567);`

## 通过 `.position` 得到的位置是相对于世界坐标系的原点位置

- 可能和面板上显示的不一样
	- 因为如果对象有父子关系并且父对象位置不在原点，那么面版上的信息肯定不一样

## 面朝向

- Z轴朝向 / Z轴与X轴朝向
- 注意坐标系的不同，面朝向的方向可能也不同

## 旋转轴

- X轴 ——> 抬头低头
- Y轴 ——> 转身
- Z轴 ——> 偏头

## 角度增量

- 目标和物体位置向量差除以每帧转动速度就是该帧要转动的角度增量

## Find 查找

- Find 查找是可以找到失活对象的，但 GameObject 却不可以

## 摄像机

- 可以通过 **清除标志** 、**剔除遮罩** 、**深度** ，一起使用来使多个摄像机叠加显示

## 物理帧与物理系统

- 物理帧更新时间直接影响物理系统

## 碰撞产生的必要条件

- 条件
	- 两个物体都有碰撞器
	- 至少一个物体有刚体
- 碰撞器表示物体的体积（形状）
- 刚体会利用体积进行碰撞计算，模拟真实的碰撞效果，产生力的作用
	- 碰撞器的体积 与 模型体积 概念不同
	- 碰撞为 碰撞器体积 进行计算，与模型体积无关

## 刚体加力

- 通过一个脚本里面去加一个方法，这个方法只会影响调用脚本的这个对象，不会影响全局

## 动量

- 力 * 时间 = 质量 * 速度

- ![[当前物体.jpg]]

- ![[运动的方向.jpg]]

## 当得到一个物体时，只要得到任意一个信息就可以得到所有信息

	- `obj.collider.gameobject.name`
		- 只得到了碰撞器信息，但依旧可以使用`gameboject`来`.name`获取名字

## Transform 与 Vector3

- `Transform`组件代表一个游戏对象在世界坐标系中的位置和方向
- `Vector3`是一个三维向量，用于表示空间中的一个点或者一个方向
- 游戏对象（ Gameobject）位移、旋转、缩放、父子关系、坐标转换等相关操作都由 Transform 处理，是一个极其重要的类
- - `this.transform.position` 类型为 `Vector3` 即 一个点

## 补充知识 调试画线 ^df038c

### 画线段 ^e8db75

- `Debug.DrawLine(this.transform.position, this.transform.position + this.transform.forward,Color.red);
	- 起点 终点
### 画射线 ^0124f8

- `Debug.DrawRay(this.transform.position,this.transform.forward,Color.white);
	- 起点 方向

## 欧拉角不是运动是变换

- [无伤理解欧拉角中的“万向死锁”现象\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1Nr4y1j7kn/)
- [[为何使用四元数#^20329c]]
- [[角度和旋转]]
- [[四元数是什么#^02493d]]
## 协同程序

- [[协同程序]]内可以写死循环
- [[协同程序]]一般不会写在 `Update`
- [[协同程序]]直接调用是没用的，但可以被一个对象接受
	- `IEnumeratorie = Test();
	- 也可以使用`.MoveNext()  .Current`手动遍历
		- 前者返回布尔值，后者为当前值
		- `.MoveNext()` 代表是否到了结尾（迭代器函数是否执行完毕） 
	- [[迭代器]]
- [[协同程序]] ^78096b
	- 分为两部分
		- 第一部分
			- 用协程函数本身（就是迭代器函数）
		- 第二部分
			- Unity 内部只要继承了 MonoBehavior 它其实就有自己的一个协程协调器
		- 第一部分 迭代器函数 决定分步进行
			- 通过 `yield return` 实现分步进行
		- 第二部分 协程协调器 决定分时进行
			- 通过 `yield return` 的返回值达到一个分时的作用
	- 总结
		- 迭代器函数 当遇到`yield return`时
		- 就会 停止执行之后的代码
		- 然后 协程协调器 通过得到 返回的值 去判断 下一次执行后面的步骤 将会是何时
## Resource
### 文件夹可以有多个 

- 在一个工程当中` Resources`文件夹 可以有多个 
	- 通过API加载时 它会自己去这些同名的`Resources`文件夹中去找资源
	- 打包时 `Resources` 文件夹 里的内容 都会打包在一起
	- [[特殊文件夹]] [[Resources资源同步加载]]
### 同一资源

- [[Resources资源同步加载]] 同一资源
	- 加载同一资源，不会造成内存浪费，但会造成性能浪费
	- 当`Resources.Load` 发现是同一个资源后，就不会在加载了
	- 加载过一次后，就会存在内存中
	- Unity 中有一个缓存区，会先在缓存区里找，没找到才会进行加载并存在缓冲区中
### 内存卡顿

- [[Resources资源同步加载]] 内存卡顿
	- 把硬盘上的一个资源的数据加载到内存当中来存储
	- 就一定把这个资源所有内容加载到内存**过后才会继续执行
		- 使用时直接拿来使用
	- 这个过程可能会大于 16.66ms （60帧），便会造成卡顿
### 原理

- [[Resources资源异步加载]]原理 ^8ede27
	- 在执行这个异步加载的这一瞬间，会新开一个线程
	- 把要加载的资源告诉这个线程，这个线程有自己的一套逻辑，专门加载这个资源
	- 新开线程加载完毕，会把资源放在一个公共的内存区
	- 主线程只要检测到资源加载完毕，就会把资源拿出来使用
	- 缺点
		- 开始的一瞬间无法使用资源，必须等待加载完成
### 易错点

- [[Resources资源异步加载]] 易错点
	- 代码
		- `ResourceRequest rg = Resources.LoadAsync<Texture>("Tex/TestJPG");`
		- `rq.completed += Loadover;`
		- `rg.asset`
	- 这样写时错的
		-  刚刚执行了异步加载的 执行代码 资源还没有加载完毕 这样用 是不对的
		- 一定要等加载结束过后 才能使用
## 场景转换

- `DontDestroyonLoad(this.game0bject);
	- 该脚本依附的对象 过场景时 不会被 移除DontDestroyonLoad(this.game0bject);
- [[场景异步加载]]
## 物理系统碰撞检测

### 必要条件

- 至少一个物体有刚体
- 两个物体都必须有碰撞器
### 碰撞和触发

- 碰撞会产生实际的物理效果
- 触发看起来不会产生碰撞但是可以通过函数监听触发
- 碰撞检测主要用于实体物体之间产生物理效果时使用
- [[唐老师/Unity 四部曲/Unity 入门/核心系统/物理系统/刚体]] [[刚体加力]] [[唐老师/Unity 四部曲/Unity 入门/核心系统/物理系统/物理材质]] [[唐老师/Unity 四部曲/Unity 入门/核心系统/物理系统/碰撞器]] [[碰撞检测函数]]
## 重要知识点：关于层级 ^bc8e6a

- 通过名字得到层级编号 `LayerMask.NameToLayer`
	- `1 << LayerMask.NameToLayer("层级名")
- 我们需要通过编号左移构建二进制数
- 这样每一个编号的层级 都是 对应位为 1 的 二进制数
- 我们通过 位运算 可以选择想要检测层级
- 好处 一个`int`就可以表示所有想要检测的层级信息
- 层级编号是 0~31 刚好32位
	- 是一个`int`数
	- 每一个编号 代表的 都是二进制的一位
		- 0 - 1 << 0 - 0000 0000 0000 0000 0000 0000 0000 0001 = 1
		- 1 - 1 << 1 - 0000 0000 0000 0000 0000 0000 0000 0010 = 2
		- 2 - 1 << 2 - 0000 0000 0000 0000 0000 0000 0000 0100 = 4
		- 3 - 1 << 3 - 0000 0000 0000 0000 0000 0000 0000 1000 = 8
		- 4 - 1 << 4 - 0000 0000 0000 0000 0000 0000 0001 0000 = 16
		- 每一个层级，都在不同位置上有且仅有一个 1
	- 检测多层时，只需要进行一个位运算 [[位运算符]]
		- 比如进行一个 或运算 
	- 就可以通过一个数字表示 n层 的一个组合
		- `1 << LayerMask.NameToLayer("层级名1") | 1 << LayerMask.NameToLayer("层级名2")
	- 在 Unity 内部，会把 或运算 的结果，把每一层的二进制数进行 与运算
		- 得到的结果只要不为 0，就会认为 **要检测** 这个层
	- 也可以进行 异或运算 结果为 0 的为 **不要检测的层级**
	  ```
		// 创建一个LayerMask，包含所有你想要检测的层级
		int layerMask = 1 << LayerMask.NameToLayer("层级名1") | 1 << LayerMask.NameToLayer("层级名2");
		// 使用Physics.OverlapBox进行检测，传入你的LayerMask
		Collider[] hitColliders = Physics.OverlapBox(center, halfSize, transform.rotation, layerMask);
		// 使用位运算排除某一层级
		layerMask = ~(1 << LayerMask.NameToLayer("不要检测的层级"));
		//也可以使用位运算中的异或运算排除某一层级
		layerMask ^= 1 << LayerMask.NameToLayer("不要检测的层级");
		// 再次进行检测，这次排除了"不要检测的层级"
		hitColliders = Physics.OverlapBox(center, halfSize, transform.rotation, layerMask);
		```
## Unity 基础总结

- 向量和四元数
	- 游戏中移动旋转都和它有关
- 协程
	- 可以分时分步处理逻辑，避免卡顿范围检测
	- 动作游戏必备
- 射线检测
	- 交互功能必备
- 资源场景的同步异步加载
	- 所有功能必备
## 对象间的父子关系

- 在 Hierarchy 中将一个对象拖动到另一个对象上而形成的树形结构
- **子对象会随着父对象的变化而变化**
- **子对象的 Inspector 窗口中 Transform 信息是相对父对象的**
## 值类型赋值相关

- 用属性和方法返回的结构体是不能修改其字段的
- 直接访问公有的结构体是可以修改其字段的
- 本质上就是值类型的浅拷贝和深拷贝，导致内存空间不同
## `[RequireComponent]

- 确保在将脚本附加到游戏对象时，该对象已经包含了脚本所需的特定组件
	- `[RequireComponent( typeof ( CharacterController ) ) ]`
## Mathf.Atan2(x,y)

^114e25
- **角色控制**
	- 在处理角色移动和转向时，你可以使用`Mathf.Atan2`来计算角色应该面向的方向
	- 例如，当玩家按下移动键时，你可以用它来确定新的转向角度，使角色朝向正确的方向移动
- **相机控制**
	- 对于摄像机的控制同样可以应用`Mathf.Atan2`
	- 在追逐目标或者跟随路径时
	- 计算所需的旋转角度来调整相机的方向
- **物体定位**
	- 如果你需要将一个物体放置在特定的角度
	- 比如对准某个目标或者与某个平面垂直
	- `Mathf.Atan2`可以帮助你计算出正确的角度值
- **导航系统**
	- 在开发游戏的AI导航系统时
	- `Mathf.Atan2`可以帮助AI确定其朝向目标的准确角度
## Mathf.SmoothDampAngle

^42a029
### 使用场景

- 在游戏中实现平滑的相机跟随效果
	- 使玩家体验更加自然流畅
- 对于需要在用户输入和实际游戏响应之间进行平滑处理的情况
	- 如缓慢移动角色或物体以响应玩家的指令
## Animator / Animation

- 设置参数 （`SetXX`）时
	- `Animator.SetFloat(string name, float value, float dampTime, float deltaTime)
		- 参数的名称
		- 要设置的新值
		- 达到目标值的时间
			- （阻尼时间）
		- 帧的增量时间
			- （通常用于计算参数值的变化速率，以便在动画过渡中实现更平滑的效果）
## Input Action Asset 

- 在Unity中用于**管理和存储用户输入的绑定关系**

## 属性与 =>
### 属性

- **用于游戏对象组件和资源的设置和选项**
	- 可以在Inspector窗口中进行编辑
- **引用属性**
- **值属性**
	- 通常用于设置组件的具体参数，如位置、速度、颜色等
- **代码层面**
	- 属性还可以有getter和setter方法
### =>

- 在C#中用于定义属性的getter方法，它简单地返回一个值或计算结果，提供了对类内部状态的只读访问
- 就是将两个变量/表达式  **关联**  起来
#### AI

想象一下你是一位餐厅的老板，你的餐厅提供各种各样的菜品。现在，你想要让顾客能够方便地了解每个菜品的信息，比如名字、价格和配料等。你可以创建一个菜单，上面列出了每个菜品的详细信息。在这个比喻中，菜单就像是C#中的属性（Property），而 `=>` 则是你用来制作菜单的方式。

具体来说，假设你有一个菜品叫“宫保鸡丁”，它的价格是25元，配料有鸡肉、花生和辣椒。在这个例子中，你可以将“宫保鸡丁”的名字、价格和配料看作是私有变量（就像你厨房里的秘密配方）。然后，你可以使用 `=>` 来创建一个菜单项，让顾客能够看到这些信息。

在C#中，你可以这样定义一个属性：

`csharp复制代码运行  public string DishName => "宫保鸡丁";`

这行代码的意思是，当别人想要知道这个菜品的名字时，你告诉他们“宫保鸡丁”。这里的 `=>` 就是用来连接菜品的实际信息（即私有变量）和你给顾客看的菜单项（即属性）的桥梁。

同样地，你也可以为价格和配料创建属性：

`public float Price => 25; public string[] Ingredients => new string[] { "鸡肉", "花生", "辣椒" };   `

- 在C#中用于定义属性的getter方法，它简单地返回一个值或计算结果，提供了对类内部状态的只读访问
- 简单理解就是
	- 利用 => 连接了变量，让左侧的值等于右侧的值（但这么说并不准确）
	- 例如：`public int b => a * 2;
		- 使用 => 将 `b` 定义为一个属性（确切来说是只读属性）
		- **每次访问**`b`时都会计算并返回 `a * 2` 的结果（即 `b` 的 值 = `a *2`）
#### 注意

- 可以与判断连用 
	- `private bool _isDie => (_currentHP <= 0f);`
	- 当前生命值小于0 就设置为 true 即死亡


## Quaternion.identity

- **一个没有应用任何旋转的四元数**
### **旋转归零**

- 通常用于将物体的旋转归零，即恢复到没有应用任何旋转的状态
- 这在编程中常常用于初始化场景或者重置物体的旋转状态
### **性能优化**

- 可以避免不必要的计算
- 特别是在不需要改变对象旋转的情况下
- 直接应用`Quaternion.identity`可以保持当前的旋转状态不变
### **父子层级关系**

- 在处理带有父子层级关系的物体时，如果父物体不可见，子物体虽然可能activeSelf为true（自身可见），但activeHierarchy只能为false（层级不可见）
- **在这种情况下，`Quaternion.identity`可以确保子物体的旋转状态不受父物体影响**
### **确切的值类型**

- 与transform.rotation属性不同，`Quaternion.identity`是一个确切的值，表示没有旋转
- 而transform.rotation是物体当前的角度属性，其值随着物体旋转而变化

## `Quaternion.LookRotation` 

- 用于**生成一个四元数，该四元数表示将给定的向量（通常是Z轴）对齐到另一个目标向量的过程所产生的旋转**
## CreateAssetMenu

- 用于在 右键菜单中 添加
- `[CreateAssetMenu(fileName = "BaseHealthData", menuName = "Create/Character/HealthData/BaseData", order = 0)]`
- ![[Unity右键菜单添加.png]]

## Physics.Raycast 和Physics.CheckSphere 的区别

- **Physics.Raycast
	- 是一种射线检测方法用于检测从起点到指定方向的一条射线上是否有任何碰撞体相交
	- 这个方法通常用来处理视线范围内的物体检测
	- 如射击游戏中的子弹击中检测或者鼠标点击物体等场景
- **Physics.CheckSphere**
	- 是用来检测世界坐标系中由位置（position）和半径（radius）界定的球体内是否有任何碰撞体的重叠
	- 当需要检测一个区域内是否存在物体时
	- 比如角色周围的敌人检测或触发某些事件，就可以使用这个方法
- Physics.Raycast 用于**直线检测**，而 Physics.CheckSphere 用于 **球形区域** 的检测
## Sprite

- 2D游戏里面的图片，都和 Sprite 有关