---
tags:
  - 科学/编程语言/Csharp/唐老师/进阶/委托和事件/委托
created: 2024-03-22
课时: "24"
来源: https://www.taikr.com/course/1144/task/35951/show
---

---
# 关联知识点

[[事件]] 

---
# 知识点

## 理解

可以理解为一个变量类型 / 一个自定义规则 （一个 “变量类型”）
这个变量类型 / 规则 就是用来存储 对应格式的函数（这个 “ 变量类型 ” 仅用于存储 函数）
委托的调用，相当于间接的调用函数

## 委托是什么

- 委托是函数（方法）的容器
- 可以理解为**表示函数（方法）的变量类型
- **用来存储、传递函数（方法）
- 委托的本质是一个类，用来自定义函数（方法）的类型（返回值和参数的类型）
- 不同的函数（方法）必须对应和各种 “ 格式 ” 一致的委托
## 基本语法

### 关键字

- `delegate`
- 单词中文意思：代表
### 语法

- `访问修饰符 delegate 返回值 委托名(参数列表);`
### 写在哪里

- 可以声明在 namespace 和 class 语句块中
- 一般情况下，更多的**写在 namespace 中
### 简单记忆委托声明

- 函数声明语法前加一个 `delegate` 关键字
## 定义自定义委托

### 访问修饰符

- 访问修饰符不写默认为 `public` 在其他命名空间也可以使用
- 如果为`private`，其他命名空间就不能用了
- 一般使用 `public`
### 示例

- `delegate void MyFun();` / `delegate 返回值 委托名(参数列表);`
	- 声明了一个可以用来存储无参无返回值函数的容器
	- 这里只是定义了规则，并没有使用
### 注意

- 委托的参数即使不同，也不能重名（同一语句块中）
## 使用定义好的委托

- 委托变量是函数的容器
- 委托常用在
	- **作为类的成员
	- **作为函数的参数
### 使用

#### 在主函数中使用

##### 第一种

- 声明
	- `Myfun f = new Myfun(Fun);` / `委托名 委托变量 = new 委托名(函数名);`
		- 只写函数名
		- 函数 `Fun` 返回值、参数列表，必须与委托 `Myfun` 相同
- 调用
	- `f.Invoke(参数列表);` / `委托变量.Inovke(参数列表)`
		- 执行存储的函数
##### 第二种

- 声明
	- `Myfun f2 = Fun;` / `委托名 委托变量 = 函数名;`
		- 只写函数名
		- 函数 `Fun` 返回值、参数列表，必须与委托 `Myfun` 相同
- 调用
	- `f2(参数列表);` / `委托变量名(参数列表);`
		- 与调用函数一样调用委托
#### 在类中使用

- `class Text{ public MyFun f1; }`
	- f1 为 委托类型的变量
		- 跟变量规则一样，只不过是装函数的变量
- `public void TextFun(Myfun f){ }`  
	- （在类中声明的一个函数）
	- 从外部传入一个委托（即传入一个函数）
- `Text t = new Text(); t.TextFun(Fun);` 
	- （在主函数声明，随后调用里面的函数，并传入一个**函数名**）
	- 注意传入的函数格式需要一致（跟委托一样）
## 委托最大作用

- 作为函数传递时 ，可以先处理一些别的逻辑，再执行传入的函数
	- 延迟执行委托（也就是延迟执行函数）
- 可以在处理逻辑时，先处理一些逻辑后，再批量处理一些逻辑
## 多播委托

- 委托变量可以存储多个函数
### 增

- **先进先调用
- 复合符号：`委托变量名 += 函数名;`
	- 也可以使用 `+`
- `Myfun f4 = Fun; f4 += Fun`
	- `f4` 里面存储了两个 `Fun` 函数，当 `f4` 被调用一次时，便会执行两次函数
	- 存储的两个函数可以不同
- `Myfun f4 = null; f4 += Fun;`
	- 也可以声明时便定为空
		- 同样，在类中以成员变量声明的委托变量，初始为空
		- 可以使用`this` 来进行指向并赋值
			- `public MyFun f1; public void TextFun(Myfun f){this.f1 += f;}`
				- （在类中 声明了一个 委托变量 f1 ）
### 减
- 复合符号：`委托变量名 -= 函数名;`
	- 也可以使用`-`
- 从容器中移除指定的函数
	- `f4 -= Fun;`
		- 多减，不会报错，无非是多处理一次
- 清空容器
	- `f4 = null;`
		- 若容器为空时，执行会报错
		- 建议使用前判断一下
## 系统委托

### **系统定义好的委托（一般都使用这个，而不是自定义委托）

- 需要引用命名空间
- 作用
	- 委托的声明时，可能因为格式相同但名字不同而导致声明了过多委托，但这些委托存储的函数都是一样的（格式一样）
	- 一些常用的委托系统已经定义好了
	- 方便理解，简洁
### `Action` 委托

- 无参无返回值的委托
- `Action action = 函数名 / new Action(函数名);`
	- `public Action action`
### `Action<T,K,……>`委托

- 最多传入十六个参数，T、K 皆为泛型（参数类型）
	- 无返回值
- `Action<int,string> action = Fun6;`
	- 函数的参数列表需要跟委托保持一致
### `Func<T>`委托

- 一个泛型委托，代表：一个可以自己填入任意类型的**有返回值**的委托
	- 更加灵活
	- 
- `Func<T> func1 = Fun4;  public T Fun4(){ return 相应的返回值 }`
	- T 为泛型（参数类型）
### `Func<T,K>`委托

- 最多传入十六个参数，最后一个参数为**返回值**类型
- T 为参数类型，K为返回值类型
## 泛型委托

- 委托是支持泛型的，可以让返回值和参数可变，更方便我们的使用
- `delegate T Myfun<T,K>(T t,K k);`
	- 声明与泛型方法一样（一般不用，更多使用系统自带的）

---
# 总结

- 简单理解 委托 就是装载、传递函数的容器而已
- 可以用委托变量 来存储函数或者传递函数的
- 系统其实已经提供了很多委托给我们用
- Action：没有返回值，参数提供了 0~16个委托给我们用
- Func：有返回值，参数提供了0~16个委托给我们用

---
# 补充

- 问题
	- 当用有返回值的委托容器存储多个函数时
	- ![[委托补充知识点1.png]]
	- ![[委托补充知识点1输出.png]]
- 解决
	- 如果想要获取到每一个函数执行后的返回值
	- 委托容器中存在方法`GetInvocationList()`可以返回一个委托数组
	- ![[委托补充知识点2.png]]
	- ![[委托补充知识点2输出.png]]

---
# 源代码

![[委托知识点.cs]]

---
# 练习题

![[委托练习题.cs]]

---

