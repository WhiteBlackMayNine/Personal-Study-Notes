
[[值类型和引用类型]]

- **值类型跟着大哥走，引用类型一根筋
	- 值类型看存在哪个东西，结构体存在栈，类则存在堆
		- 无论在哪里，都是直接存放它的值
	- 引用类型只存在堆里
		- 先存地址，再指向堆中的内存
			- 即使是直接存放在堆中，也是先存一个地址，再指向堆中一块内存空间

课时49

- 如何判断 值类型和引用类型
	- F12进到类型的内部去查看
	- 是`class`就是引用
	- 是`struct`就是值
- 语句块
	- 包含关系
		- 命名空间 ——>
			-  ——> 类、接口、结构体  ——>
				-  ——> 函数、属性、索引器、运算符重载等（类、接口、结构体） ——>
					-  ——> 条件分支、循环
	- 层次
		- 上层语句块
			- 类、结构体
		- 中层语句块
			- 函数
		- 底层的语句块
			- 条件分支 循环等
	- 逻辑代码写在哪里
		- 函数、条件分支、循环
			- 中底层语句块中
	- 变量可以声明在哪里
		- 上、中、底都能申明变量
			- 上层语句块
				- 成员变量
			- 中、底层语句块中
				- 临时变量
- 变量的生命周期
	- 编程时大部分都是 临时变量
	- 在中底层申明的临时变量（函数、条件分支、循环语句块等）
		- 语句块执行结束
			- 没有被记录的对象将被回收或变成垃圾
				- 值类型
					- 被系统自动回收
				- 引用类型
					- 栈上用于存地址的房间被系统自动回收，堆中具体内容变成垃圾，待下次GC回收
	- 想要不被回收或者不变垃圾
		- 必须将其记录下来
	- 如何记录
		- 在更高层级记录或者
		- 使用静态全局变量记录
	- 注意
		- `while(true){ int index = 1;` 
			- 在栈上存储新的一个房间，但每次循环都会弹出这个栈
				- 会造成大量性能消耗
- 结构体中的值和引用
	- 结构体本身是值类型
		- 前提
			- 该结构体没有做为其它类的成员
	- 值和引用
		- 在结构体中的值，**栈中存储值具体的内容
		- 在结构体中的引用，**堆中存储引用具体的内容
	- 引用类型**始终存储在堆中
	- 真正通过结构体使用其中引用类型时只是“顺藤摸瓜”
		- 实例化对象时，实际上也是在堆里面生成，引用类型存放在栈上的`null`会改为执行堆的地址
		- 结构体中的引用类型在栈中只会存放地址，真正赋值时，还是在堆中分配空间
- 类中的值和引用 ^144681
	- 类本身是引用类型
		- 在类中的值，堆中存储具体的值
		- 在类中的引用，堆中存储具体的值
	- 值类型跟着大哥走，引用类型一根筋
		- 值类型看存在哪个东西，结构体存在栈，类则存在堆
		- 引用类型只存在堆里
- 数组中的存储规则
	- 数组本身是引用类型
		- 值类型数组，堆中房间存具体内容
		- 引用类型数组，堆中房间存地址
- 结构体继承接口
	- 利用里氏替换原则，用接口容器装载结构体存在装箱拆箱

- 知识点
	- ![[值和引用类型补充知识点.cs]]