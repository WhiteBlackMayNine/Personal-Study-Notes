---
tags:
  - 科学/编程语言/Csharp/唐老师/小知识点
备注: 日积月累 厚积薄发
---

---
# 知识点

## 折叠代码

- 折叠代码 ^3d9e0f
	- 主要作用
		- 编程时逻辑更清晰
		- 将中间包裹起来的代码折叠起来。避免太凌乱
	- 本质
		- 编辑器提供的预处理指令
		- 只会在编辑时有用，发布代码或执行代码会自动删除
	- 代码
	  ```C#
	  #region 描述
	   代码
	  #endregion 
		```


## 数值转换默认为向下取整


## 按F12可以查看重载、函数等


## 三个斜杆的注释，可以使得鼠标停留时有额外信息

目标对象是下方
## 引用类型和 `new`

- **引用类型与`new`（C# 核心 课时4）
	- `new` 会在栈中开辟空间存放地址，并且指向堆中内存
	- `null` 会使栈中内存变为空，从而无法指向堆中内存
	- `B = A` ——> 将 A 的地址拷贝给 B ，意思是在栈中有两块地址，但都指向同一个堆中内存
		- 若`B = null` ——> B 的地址变为空，但A的地址不受影响
		- 若`B = new……` ——> B的地址改变，指向堆中一个新的内存，但A的地址不受影响
	- 可以使用断点来观察
## 优先级

- 优先级
	- 乘除取余加减
	- 括号最大
	- 多组括号从内到外依次计算
## `this`

- `this`
	- 在函数中表示对象自己
	- 在构造函数中表示要调用一个构造函数前调用另一个构造函数

## `value`

- `value`
	- 在`set`中，为在主函数中传入的值
## 声明数组

- 声明数组
	- `int[] ints; ints = new int[10]; `可以分为两步进行

## 短生命周期可以调用长生命周期，反之不成立


## 静态过多会占用固定资源，不能滥用


## 单例模式

^443034

- 单例模式
	- 两个静态
		- 一个静态实例化对象，一个静态实例化对象的成员属性（只有 `get`）
	- 一个类对象，在整个应用程序的生命周期中，有且仅会有一个该对象的存在
	- 不能在外部实例化，直接通过该类类名就能够得到唯一的对象
	- 方法
		- 写一个私有的构造函数
			- `private 类型(){ }`
		- 在类内部进行一个私有的实例化
			- `public static 类名 对象名1 = new 类名();`
		- 利用成员属性保护
			- `public static 类名 对象名2{ get{ return 对象名1 } }`
	- 代码
		- ![[静态类与单例.cs]]
## 父类和子类

- 父类和子类
	- 就像树枝和树干一样，只能有一个树干，但可以有无数个树枝
- 不能用子类装载父类
- 在子类继承父类时，父类的构造函数**会被调用**
## `is as`

- `is as ^30a19e
	- 并不局限于类和对象中
	- `is` 值类型和引用类型都可以使用
	- `as` 只能用于引用类型或可空值类型（nullable value type）

## 虚方法和抽象方法可以不停的重写


## 写接口时不写访问修饰符


## 接口最大作用

- 接口最大作用
	- 用接口装载拥有相同行为的不同类型的对象
## 类中的值类型

- `class Text { public int i = 1;}`
	- 包裹在类中，内存存放在堆中，而不是栈中
## `new string(char)`
- `str = new string(chars)`
	- 通过构造函数来 new 出一个字符串
	- chars 为一个字符数组
	- 但很少用
## ASCII码 进行两个字符的转换

- 利用 ASCII 码进行两个字符的转换
	- 示例代码
		- `chars[i]=(char)(chars[i]+ chars[chars.Length-1- i]); 
		- `chars[chars.Length-1-i]=(char)(chars[i]-chars[chars.Length -1- i]); 
		- `chars[i]=(char)(chars[i]-chars[chars.Length-1-i]);
	- 原理（AI）
		- 原理是通过数学运算来实现交换，具体步骤如下
			- 将 `chars[i]` 的值加上 `chars[chars.Length-1-i]` 的值，并将结果转换为 `char` 类型，然后将结果赋值给 `chars[i]`
			- 将 `chars[i]` 减去 `chars[chars.Length-1-i]` 的值，并将结果转换为 `char` 类型，然后将结果赋值给 `chars[chars.Length-1-i]`
			- 再次将 `chars[i]` 减去 `chars[chars.Length-1-i]` 的值，并将结果转换为 `char` 类型，然后将结果赋值给 `chars[i]`
		- 通过这三步操作，实现了 `chars[i]` 和 `chars[chars.Length-1-i]` 的交换
## `string`
- `string`
	- 每次重新赋值或拼接时会分配新城内存空间
	- 如果一个字符串经常修改会非常浪费空间
## 如何优化内存

- **如何优化内存
	- 方向
		- 如何节约内存
		- 如何尽量少的进行GC
	- 方法
		- 少`new`对象，少产生垃圾
		- 合理使用`static
		- 合理使用`string StringBuilder
## ArrayList和数组的区别

- ArrayList和数组的区别
	- ArrayList本质上是一个object数组的封装
	- Arrayuist可以不用一开始就定长，单独使用数组是定长的
	- 数组可以指定存储类型，ArrayList默认为object类型
	- 数组的增删需要我们自己去实现，ArrayList帮我们封装了方便的API来使用
	- ArrayList使用时可能存在装箱拆箱，数组使用时只要不是object数组那就不存在这个问题
	- 数组长度为Length，ArrayList长度为Count
## 栈的先进后出

- 栈的先进后出
	- ![[栈的先进后出.png]]
## 普通类和泛型类是两个东西

- 普通类和泛型类是两个东西
	- 如果重名也会因为加了泛型而变成两个不同的类
## 获取字节数

- 获取字节数
	- `sizeof
## 抽象类、接口 不能 new


## 容量（C#核心中提到）可以避免垃圾产生


## 顺序存储、链式存储 是数据结构中两种存储结构


## `.Value`

- `.Value`
	- 获取链表节点对象的值（[[LinkedList]]）
## 函数本质也是数据

- [[CSharp/唐老狮/基础/函数/函数]]本质上也是一种数据
## 委托传入函数

- [[委托]]传入函数时，[[CSharp/唐老狮/基础/函数/函数]]不需要写，`()` 如果写，那么需要确保`()`内可以返回一个委托 
## 委托做返回值

- [[委托]]也可以作为函数返回值
	- `Text t = new Text();` Text 为一个类
	- `t.Dosomething( 函数名/委托名 )` 为类中一个方法
## `foreach` 本质

- `foreach`本质
	- 先获取`in`后面这个对象的` IEnumerator`
		- 会调用对象其中的`GetEnumerator`方法来获取
	- 执行得到这个`IEnumerator`对象中的 `MoveNext`方法
	- 只要`MoveNext`方法的返回值时`true`就会去得到`Current`
		- 然后复制给`item
## 语法糖

- 语法糖 ^5cab31
	- 所谓语法糖，也称糖衣语法
	- 主要作用就是将复杂逻辑简单化，可以增加程序的可读性
	- 从而减少程序代码出错的机会
## 集合对象

- 集合对象
	- [[Dictionary]]、[[LinkedList]]、[[List]]、[[Arraylist]]、[[Hashtable]]、[[Queue]]、[[Stack]]以及[[CSharp/唐老狮/基础/复杂数据类型/数组]]
## ？运算符

- `?`
	- [[三目运算符]]
	- [[特殊语法#^e3a756]]
## 类中的引用类型

- 类中的引用类型
	- [[值类型和引用类型补充#^144681]]
	- 类的整体（除去引用类型）会放在堆中的一块内存
	- 剩下的引用类型则会单独分配在堆中的不同内存中

## 默认值

^549c78

- 默认值
	- **switch语句中的默认情况**
		- 在`switch`语句中，`default`用于标记当没有任何`case`条件匹配时程序应该执行的代码块的开始位置
		- 这是`switch`语句的标准结构的一部分，确保了所有可能的情况都被处理
	- **泛型类型的默认值**
		- 在泛型编程中，`default()`可以用于获取任何类型的默认值
		- 对于引用类型，它将返回`null`；对于可空类型，它将返回一个没有值的可空对象
		- 对于值类型，它将返回一个具有所有成员都设置为其默认值的对象
	- **类中的默认函数**
		- 在C#类中，`default`可以用于指定默认的成员函数，如默认构造函数、拷贝构造函数等
		- 这在C++中更为常见，但在C#中也有类似的用法，尤其是在与C++交互的情况下
	- **变量初始化**
		- 在声明变量时，如果没有显式地初始化变量，C#会自动使用`default()`来初始化变量
	- **判断默认值**
		- 在某些情况下，可能需要判断一个变量是否为其类型的默认值
		- 直接使用`==`运算符可能会引发编译错误，因为不是所有的类型都重载了`==`运算符
		- 在这种情况下，可以使用`object.Equals(objA, objB)`来判断两个对象是否相等
		- 或者使用泛型方法来实现更通用的比较逻辑