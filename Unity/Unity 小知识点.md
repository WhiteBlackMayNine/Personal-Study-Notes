---
tags:
  - 科学/Unity/Unity小知识点
备注: 日积月累 厚积薄发
核心: 游戏是数据的一种表现
---

---


## Unity中打印信息的两种方式

- 没有继承MonoBehavior类的时候
	- `Debug.Log();`
- 继承了MonoBehavior有一个线程的方法可以使用
	- `print(1234567);`

## 通过 `.position` 得到的位置是相对于世界坐标系的原点位置

- 可能和面板上显示的不一样
	- 因为如果对象有父子关系并且父对象位置不在原点，那么面版上的信息肯定不一样

## 面朝向

- Z轴朝向 / Z轴与X轴朝向
- 注意坐标系的不同，面朝向的方向可能也不同

## 旋转轴

- X轴 ——> 抬头低头
- Y轴 ——> 转身
- Z轴 ——> 偏头

## 角度增量

- 目标和物体位置向量差除以每帧转动速度就是该帧要转动的角度增量

## Find 查找

- Find 查找是可以找到失活对象的，但 GameObject 却不可以

## 摄像机

- 可以通过 **清除标志** 、**剔除遮罩** 、**深度** ，一起使用来使多个摄像机叠加显示

## 物理帧与物理系统

- 物理帧更新时间直接影响物理系统

## 碰撞产生的必要条件

- 条件
	- 两个物体都有碰撞器
	- 至少一个物体有刚体
- 碰撞器表示物体的体积（形状）
- 刚体会利用体积进行碰撞计算，模拟真实的碰撞效果，产生力的作用
	- 碰撞器的体积 与 模型体积 概念不同
	- 碰撞为 碰撞器体积 进行计算，与模型体积无关

## 刚体加力

- 通过一个脚本里面去加一个方法，这个方法只会影响调用脚本的这个对象，不会影响全局

## 动量

- 力 * 时间 = 质量 * 速度

- ![[当前物体.jpg]]

- ![[运动的方向.jpg]]

## 当得到一个物体时，只要得到任意一个信息就可以得到所有信息

	- `obj.collider.gameobject.name`
		- 只得到了碰撞器信息，但依旧可以使用`gameboject`来`.name`获取名字

## Transform 与 Vector3

- `Transform`组件代表一个游戏对象在世界坐标系中的位置和方向
- `Vector3`是一个三维向量，用于表示空间中的一个点或者一个方向
- 游戏对象（ Gameobject）位移、旋转、缩放、父子关系、坐标转换等相关操作都由 Transform 处理，是一个极其重要的类
- - `this.transform.position` 类型为 `Vector3` 即 一个点

## 补充知识 调试画线 ^df038c

### 画线段 ^e8db75

- `Debug.DrawLine(this.transform.position, this.transform.position + this.transform.forward,Color.red);
	- 起点 终点
### 画射线 ^0124f8

- `Debug.DrawRay(this.transform.position,this.transform.forward,Color.white);
	- 起点 方向

## 欧拉角不是运动是变换

- [无伤理解欧拉角中的“万向死锁”现象\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1Nr4y1j7kn/)
- [[为何使用四元数#^20329c]]
- [[角度和旋转]]
- [[四元数是什么#^02493d]]
## 协同程序

- [[协同程序]]内可以写死循环
- [[协同程序]]一般不会写在 `Update`
- [[协同程序]]直接调用是没用的，但可以被一个对象接受
	- `IEnumeratorie = Test();
	- 也可以使用`.MoveNext()  .Current`手动遍历
		- 前者返回布尔值，后者为当前值
		- `.MoveNext()` 代表是否到了结尾（迭代器函数是否执行完毕） 
	- [[迭代器]]
- [[协同程序]] ^78096b
	- 分为两部分
		- 第一部分
			- 用协程函数本身（就是迭代器函数）
		- 第二部分
			- Unity 内部只要继承了 MonoBehavior 它其实就有自己的一个协程协调器
		- 第一部分 迭代器函数 决定分步进行
			- 通过 `yield return` 实现分步进行
		- 第二部分 协程协调器 决定分时进行
			- 通过 `yield return` 的返回值达到一个分时的作用
	- 总结
		- 迭代器函数 当遇到`yield return`时
		- 就会 停止执行之后的代码
		- 然后 协程协调器 通过得到 返回的值 去判断 下一次执行后面的步骤 将会是何时
## Resource
### 文件夹可以有多个 

- 在一个工程当中` Resources`文件夹 可以有多个 
	- 通过API加载时 它会自己去这些同名的`Resources`文件夹中去找资源
	- 打包时 `Resources` 文件夹 里的内容 都会打包在一起
	- [[特殊文件夹]] [[Resources资源同步加载]]
### 同一资源

- [[Resources资源同步加载]] 同一资源
	- 加载同一资源，不会造成内存浪费，但会造成性能浪费
	- 当`Resources.Load` 发现是同一个资源后，就不会在加载了
	- 加载过一次后，就会存在内存中
	- Unity 中有一个缓存区，会先在缓存区里找，没找到才会进行加载并存在缓冲区中
### 内存卡顿

- [[Resources资源同步加载]] 内存卡顿
	- 把硬盘上的一个资源的数据加载到内存当中来存储
	- 就一定把这个资源所有内容加载到内存**过后才会继续执行
		- 使用时直接拿来使用
	- 这个过程可能会大于 16.66ms （60帧），便会造成卡顿
### 原理

- [[Resources资源异步加载]]原理 ^8ede27
	- 在执行这个异步加载的这一瞬间，会新开一个线程
	- 把要加载的资源告诉这个线程，这个线程有自己的一套逻辑，专门加载这个资源
	- 新开线程加载完毕，会把资源放在一个公共的内存区
	- 主线程只要检测到资源加载完毕，就会把资源拿出来使用
	- 缺点
		- 开始的一瞬间无法使用资源，必须等待加载完成
### 易错点

- [[Resources资源异步加载]] 易错点
	- 代码
		- `ResourceRequest rg = Resources.LoadAsync<Texture>("Tex/TestJPG");`
		- `rq.completed += Loadover;`
		- `rg.asset`
	- 这样写时错的
		-  刚刚执行了异步加载的 执行代码 资源还没有加载完毕 这样用 是不对的
		- 一定要等加载结束过后 才能使用

## 场景转换

- `DontDestroyonLoad(this.game0bject);
	- 该脚本依附的对象 过场景时 不会被 移除DontDestroyonLoad(this.game0bject);
- [[场景异步加载]]

## 物理系统碰撞检测

### 必要条件

- 至少一个物体有刚体
- 两个物体都必须有碰撞器
### 碰撞和触发

- 碰撞会产生实际的物理效果
- 触发看起来不会产生碰撞但是可以通过函数监听触发
- 碰撞检测主要用于实体物体之间产生物理效果时使用
- [[刚体]] [[刚体加力]] [[物理材质]] [[碰撞器]] [[碰撞检测函数]]

## 重要知识点：关于层级 ^bc8e6a

- 通过名字得到层级编号 `LayerMask.NameToLayer`
	- `1 << LayerMask.NameToLayer("层级名")
- 我们需要通过编号左移构建二进制数
- 这样每一个编号的层级 都是 对应位为 1 的 二进制数
- 我们通过 位运算 可以选择想要检测层级
- 好处 一个`int`就可以表示所有想要检测的层级信息
- 层级编号是 0~31 刚好32位
	- 是一个`int`数
	- 每一个编号 代表的 都是二进制的一位
		- 0 - 1 << 0 - 0000 0000 0000 0000 0000 0000 0000 0001 = 1
		- 1 - 1 << 1 - 0000 0000 0000 0000 0000 0000 0000 0010 = 2
		- 2 - 1 << 2 - 0000 0000 0000 0000 0000 0000 0000 0100 = 4
		- 3 - 1 << 3 - 0000 0000 0000 0000 0000 0000 0000 1000 = 8
		- 4 - 1 << 4 - 0000 0000 0000 0000 0000 0000 0001 0000 = 16
		- 每一个层级，都在不同位置上有且仅有一个 1
	- 检测多层时，只需要进行一个位运算 [[位运算符]]
		- 比如进行一个 或运算 
	- 就可以通过一个数字表示 n层 的一个组合
		- `1 << LayerMask.NameToLayer("层级名1") | 1 << LayerMask.NameToLayer("层级名2")
	- 在 Unity 内部，会把 或运算 的结果，把每一层的二进制数进行 与运算
		- 得到的结果只要不为 0，就会认为 **要检测** 这个层
	- 也可以进行 异或运算 结果为 0 的为 **不要检测的层级**
	  ```
		// 创建一个LayerMask，包含所有你想要检测的层级
		int layerMask = 1 << LayerMask.NameToLayer("层级名1") | 1 << LayerMask.NameToLayer("层级名2");
		// 使用Physics.OverlapBox进行检测，传入你的LayerMask
		Collider[] hitColliders = Physics.OverlapBox(center, halfSize, transform.rotation, layerMask);
		// 使用位运算排除某一层级
		layerMask = ~(1 << LayerMask.NameToLayer("不要检测的层级"));
		//也可以使用位运算中的异或运算排除某一层级
		layerMask ^= 1 << LayerMask.NameToLayer("不要检测的层级");
		// 再次进行检测，这次排除了"不要检测的层级"
		hitColliders = Physics.OverlapBox(center, halfSize, transform.rotation, layerMask);
		```

## Unity 基础总结

- 向量和四元数
	- 游戏中移动旋转都和它有关
- 协程
	- 可以分时分步处理逻辑，避免卡顿范围检测
	- 动作游戏必备
- 射线检测
	- 交互功能必备
- 资源场景的同步异步加载
	- 所有功能必备


## 对象间的父子关系

- 在 Hierarchy 中将一个对象拖动到另一个对象上而形成的树形结构
- **子对象会随着父对象的变化而变化**
- **子对象的 Inspector 窗口中 Transform 信息是相对父对象的**