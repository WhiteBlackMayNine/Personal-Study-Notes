---
tags:
  - "#Cpp"
  - "#算法"
created: 2025-05-07
---

---
# 关联知识点

[[031 数组的三角和]]

---
# 题目

给你一个下标从 0 开始的整数数组 `nums` ，数组长度为 偶数 ，由数目 相等 的正整数和负整数组成。

你需要返回满足下述条件的数组 `nums`：

1. 任意 连续 的两个整数 符号相反
2. 对于符号相同的所有整数，保留 它们在 `nums` 中的 顺序 。
3. 重排后数组以正整数开头。

重排元素满足上述条件后，返回修改后的数组。

# 示例

示例 1：

输入：`nums = [3,1,-2,-5,2,-4]`
输出：`[3,-2,1,-5,2,-4]`
解释：
nums 中的正整数是 `[3,1,2]` ，负整数是 `[-2,-5,-4] `。
重排的唯一可行方案是 `[3,-2,1,-5,2,-4]`，能满足所有条件。
像 `[1,-2,2,-5,3,-4]`、`[3,1,2,-2,-5,-4]`、`[-2,3,-5,1,-4,2]` 这样的其他方案是不正确的，因为不满足一个或者多个条件。 

示例 2：

输入：`nums = [-1,1]`
输出：`[1,-1]`
解释：
1 是 nums 中唯一一个正整数，-1 是 nums 中唯一一个负整数。
所以 nums 重排为 `[1,-1]`。

# 题解

双指针
第一个指针 pos 遍历所有的正整数，而第二个指针 ncg 则遍历所有的负整数
因为数组的长度为偶数且正负整数各占一半
所以双指针的遍历操作只需要指向 `num.size() / 2` 次便可

当找到一个正整数 / 负整数时，跳出 while 循环，将其插入到数组中
然后将指针自增，跳过插入的值（也就是指向下一个值，继续循环遍历 `nums` 数组）

# 代码

```C++
class Solution {  
public:  
    vector<int> rearrangeArray(vector<int> &nums) {  
        int size = nums.size();  
        int pos = 0, ncg = 0;  
  
        vector<int> arr;  
  
        for (int i = 0; i < size / 2; ++i) {  
            while (nums[pos] < 0) {  
                pos++;  
            }  
  
            arr.push_back(nums[pos]);  
            pos++;  
  
            while (nums[ncg] > 0) {  
                ncg++;  
            }  
            arr.push_back(nums[ncg]);  
            ncg++;  
        }  
  
        return arr;  
    }  
};
```


---
