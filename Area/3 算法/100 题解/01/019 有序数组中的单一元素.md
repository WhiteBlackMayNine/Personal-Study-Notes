---
tags:
  - "#Cpp"
  - "#算法"
created: 2025-05-06
---

---
# 关联知识点

[[020 基于排列构建数组]]

---
# 题目

给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 `O(log n)` 时间复杂度和 `O(1)` 空间复杂度。

# 示例

**示例 1:**

**输入:** `nums = [1,1,2,3,3,4,4,8,8]`
**输出:** 2

**示例 2:**

**输入:** `nums =  [3,3,7,7,10,11,11]`
**输出:** 10

# 题解

线性枚举 暴力解法
从数组的第二个元素开始，到倒数第二个结束
如果一个元素的值与前后两个值都不同，那么这个元素就是要找的

如果整个 `for` 循环都没找到，那么就说明要找到元素不是第一个就是最后一个
因为代码最后是需要返回一个值的，所以我们只需要判断第一个元素是否是目标值

如果数组大小为 1，或者第一个元素的值不等于第二个元素，那么返回出去就行

同样的，如果走到最后都没有找到，就说明要找的目标是数组的最后一个元素

# 代码

```C++
class Solution {  
public:  
    int singleNonDuplicate(vector<int> &nums) {  
  
        for (int i = 1; i < nums.size() - 1; ++i) {  
            if (nums[i] != nums[i - 1] && nums[i] != nums[i + 1]) {  
                return nums[i];  
            }  
        }  
  
        if (nums.size() == 1) {  
            return nums[0];  
        }  
  
        if (nums[0] != nums[1]) {  
            return nums[0];  
        }  
  
        return nums.back();  
    }  
};
```


---
