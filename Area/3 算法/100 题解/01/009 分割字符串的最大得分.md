---
tags:
  - "#Cpp"
  - "#算法"
created: 2025-05-03
---

---
# 关联知识点

[[010 统计范围元音字符串数]] [[02 string]]

---
# 题目

给你一个由若干 0 和 1 组成的字符串 `s` ，请你计算并返回将该字符串分割成两个 **非空** 子字符串（即 **左** 子字符串和 **右** 子字符串）所能获得的最大得分。

「分割字符串的得分」为 **左** 子字符串中 **0** 的数量加上 **右** 子字符串中 **1** 的数量

# 示例

**示例 1：**

输入：s = "011101"
输出：5 
解释：
将字符串 s 划分为两个非空子字符串的可行方案有：
左子字符串 = "0" 且 右子字符串 = "11101"，得分 = 1 + 4 = 5 
左子字符串 = "01" 且 右子字符串 = "1101"，得分 = 1 + 3 = 4 
左子字符串 = "011" 且 右子字符串 = "101"，得分 = 1 + 2 = 3 
左子字符串 = "0111" 且 右子字符串 = "01"，得分 = 1 + 1 = 2 
左子字符串 = "01110" 且 右子字符串 = "1"，得分 = 2 + 1 = 3

**示例 2：**

输入：s = "00111"
输出：5
解释：当 左子字符串 = "00" 且 右子字符串 = "111" 时，我们得到最大得分 = 2 + 3 = 5

**示例 3：**

输入：s = "1111"
输出：3

# 题解
枚举分割线的位置。

设前缀（左子字符串）中 0 的个数为 left0，后缀（右子字符串）中 1 的个数为 right1
​

设分割线在 s[i] 和 s[i+1] 之间，s=011101 的计算过程如下：


| $i$ | 分割线        | `left0` | `right1` | 得分  |
| --- | ---------- | ------- | -------- | --- |
| 0   | $0\|11101$ | 1       | 4        | 5   |
| 1   | $01\|1101$ | 1       | 3        | 4   |
| 2   | $011\|101$ | 1       | 2        | 3   |
| 3   | $0111\|01$ | 1       | 1        | 2   |
| 4   | $01110\|1$ | 2       | 1        | 3   |

> 注意至多计算到 $i=n−2$，因为题目要求前缀以及后缀必须是**非空**的

`left0`​ 可以在遍历 s 的过程中计算
`right1​` 呢？我们可以在枚举分割线之前，先统计整个 `s` 中的 1 的个数。

然后再枚举分割线：
- 如果 `s[i]=0`，那么把 `1` ​ 增加 1
- 否则 `s[i]=1`，那么把 `right1`​ 减少 1。因为 `s[i]` 之前在分割线右侧，现在属于分割线左侧了

简单来说
就是先统计字符串中 1 的数量
然后根据分割线，每割一次就更新一次 `left0 right1` 的
# 代码

```C++
class Solution {  
public:  
    int maxScore(string s) {  
        int right = ranges::count(s, '1');  
        int left = 0;  
        int sum = 0;  
        for (int i = 0; i < s.size() - 1; ++i) {  
            if (s[i] == '0') {  
                left++;  
            } else {  
                right--;  
            }  
            sum = max(sum, left + right);  
        }  
  
        return sum;  
    }  
};
```


---

[^1]: 
