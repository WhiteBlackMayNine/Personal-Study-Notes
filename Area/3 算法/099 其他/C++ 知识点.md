---
tags:
  - "#Cpp"
created: 2025-04-17
---

---
# 关联知识点



---
# 系统排序头文件

`# include <algorithm>`
排序方法：`sort(s.begin(),s.end());` 左闭右开区间
# 结构体作为参数传参

^a17cc2

不同于其他语言，C++使用结构体做为参数进行传参时
是拷贝了一份数据进去

> 函数内的结构体和外部的结构体 两者地址不同

如果结构体内的数据十分大，那么建议函数参数加上引用，减少传参耗时
（避免这次拷贝）
# 浅拷贝与深拷贝
## 浅拷贝

会直接复制值，与指针的值，也就是指针指向的内存地址，但不会复制指针指向的内存内容
导致两个变量，它们的指针指向的地址都是 `0x235`（假设是这个地址），但内存内容没有复制
那么这两个变量就会共享一个内存内容

简单来说，就是复制了门牌号，但没有把房子也复制了，两个变量有相同的门牌号，同时共用一个房子
修改其中一个变量，另外一个变量也会受到影响
# 深拷贝

深拷贝会分配新的内存
进行深拷贝的过程中，指针指向的内存地址会拷贝过来，同时会将内存内容也拷贝一份过来
这就导致了 两个变量，相同的门牌号，但有两个房子
# 拷贝构造函数

> 拷贝构造函数使用的是深拷贝

一般情况下，当使用赋值号将一个对象赋值给另外一个对象的时候，会调用拷贝构造函数
确保新对象拥有独立资源副本
防止多个对象共享同一内存（修改一个对象影响其他对象、重复释放内存导致崩溃）

```C++
MyClass c1 = 赋值操作;
MyClass c2;
c2 = c1;//调用拷贝构造函数

//拷贝构造函数
MyClass(const MyClass& s){}
```

即：当一个对象执行构造函数的时候，会根据参数类型来选择不同的构造函数
无参数：调用默认构造函数
同类型参数：调用拷贝构造函数（需要手动书写）
其他类型参数：调用相匹配的构造函数

请注意：如果没有手动书写拷贝构造函数，那么进行调用的时候可能会选择其他的构造函数
# 头插法

```C++
//头插法
childrenNode->next = childrenHead;  
childrenHead = childrenNode;

//原本的链表结构
childrenHead → [Node1] → [Node2] → ... → nullptr
//childrenNode->next = childrenHead;  操作后的链表结构
childrenNode->next = childrenHead;
//结果
childrenNode → [原 childrenHead 指向的链表]
//childrenHead = childrenNode; 操作后结果
childrenHead → [新节点] → [原链表] → ... → nullptr

//依次插入 A B C 三个结点
ChildrenHead → [A] → nullptr
childrenHead → [B] → [A] → nullptr
childrenHead → [C] → [B] → [A] → nullptr
```
# 递归

本质是函数调用自身，每次调用会生成一个新的函数执行上下文，并压入调用栈（Call Stack）
**当前函数会暂停，直到子调用返回后，才会继续执行后续代码**

如二叉树中序遍历

```C++
void Tree<T>::inOrder(TreeNode<T> *node) {
    if (node) {
        inOrder(node->leftNode);  // 步骤1：递归左子树
        visit(node);             // 步骤2：访问当前节点
        inOrder(node->rightNode); // 步骤3：递归右子树
    }
}

//流程图

调用顺序：
inOrder(A)
│
├─ inOrder(B)           ← A的递归暂停，先处理B
│  │
│  ├─ inOrder(C)        ← B的递归暂停，先处理C
│  │  │
│  │  ├─ inOrder(nullptr) → 返回
│  │  ├─ visit(C)         → 输出C
│  │  ├─ inOrder(nullptr) → 返回
│  │
│  ├─ visit(B)          → 输出B
│  ├─ inOrder(nullptr)  → 返回
│
├─ visit(A)             → 输出A
├─ inOrder(nullptr)     → 返回

//最终结果
C → B → A
```
# Char 数组如何打印首地址

```C++
char a[100] = "dawd0";
cout << a << endl;//直接打印将会输出 dawd0
cout << (void *)a << endl;//输出首地址
```
# 栈 与 堆

> 栈在初始化的时候必须指明要申请的内存空间，因为栈无法动态分配内存

- 栈是一种后进先出（LIFO）的数据结构，用于存储局部变量
- 当一个函数被调用时，系统会为该函数的局部变量在栈上分配内存，当函数执行完毕后，这些内存会被自动释放

- 在函数内部定义的变量，如果没有使用动态内存分配操作符（如 new）
- 那么这些变量是在栈上分配内存的。如果有一个指针指向这样的变量，那么它指向的就是栈上的内存

> 堆可以动态分配内存

- - 堆是一种用于动态内存分配的内存区域
- 通过使用 new 操作符在堆上分配内存，而通过 delete 操作符释放内存

指针和引用指向的位置，取决于 变量 分配到哪里
# Sort 排序方法

如果里面不传入参数，那么默认就是升序排序
但是，如果传入了一个比较函数 `cmp(a,b)` 那么 Sort 方法就会根据其返回值
决定使用的排序方式
即：当 `cmp` 返回为 `true` 时，`a` 会排在 `b` 的前面；返回为 `false` 时则反之

关于比较函数：需要满足**严格弱序**

- **非自反性**
	- `cmp(a, a)`必须为`false`
- **非对称性**
	- 若`cmp(a, b)`为`true`，则`cmp(b, a)`必须为`false`
- **传递性**
	- 若`cmp(a, b)`和`cmp(b, c)`为`true`，则`cmp(a, c)`必须为`true`

比较函数的返回值可以为 `int` 或者 `bool`
参数可以使用 `const` 或者 `&`

# 自增 / 自减

前置++：先++再计算
后置++：先用原值计算，再执行++

---
