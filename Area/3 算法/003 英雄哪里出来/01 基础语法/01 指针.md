---
tags:
  - "#Cpp"
created: 2025-04-17
---

---
# 关联知识点

[[02 结构体]]

---
# 概念

用一个变量变量存储内存中的一个地址
这个变量就叫 *指针*
# 指针的定义和使用

`数据类型 *指针变量名` 如 `int *a`
# 解引用

`*指针变量名 = 数值` 如 `*a = 10; cout << (*a);`
# 取地址

`&变量名 = 地址`
对一个变量使用 `&` 将会得到这个变量在内存的位置
# 指针的内存空间

32 位操作系统为 4
64 为操作系统为 8
# 空指针与野指针

定义指针时赋值为 `NULL`，同时后面也没有为其赋值
进行解引用时，会报 **空指针** 错误
`int *p = NULL; cout << (*p)l`

如果定义指针时，直接赋值，那么地址可能是错乱的

`int *p = (int *)0x121412`
# 指针常量与常量指针

> 指针 的 常量
> 常量 的 指针

指针常量 `int * const a` 指针的值是一个常量，也就是指针存储的地址，无法改变

常量指针 `const int *a` 常量的指针，指针存储的地址可以改变，但变量的值无法改变
## 常量指针常量

`const int *const a` 同时有 指针常量 与 常量指针 的特性
存储的地址和变量的值都无法改变
# 指针和数组的关系

指针不是数组，两者不可互相转换

> 指针是地址，数组名也是一个地址，但两者并不等同
## 指针访问数组元素

```C++
int a[100];
int *p = a;//数组名 就是 这个数组的 首地址
cout << *p << *(p + 1);//数组的 首元素 第二个元素
```

只要让指针进行偏移，就能在数组的位置上进行相应的偏移

请注意 `p + 2` 确实往后偏移两位，但是，`p` 的地址仍然指向数组首地址
`p++` 将会修改 `p` 指针指向的地址

指针的 `++/--` 会根据自己的类型，来进行相应的偏移
如 `int` 每次偏移移动 4 个字节，`double` 则移动 8 个字节 、
实际上就是偏移 `sizeof(对应指针类型)` 个字节
# 指针数组

> 指针 的 数组
> 类型为指针 的 数组

由指针构成的数组
可以让一些不相关的变量组合在一起

```C++
char a[] = "adada";
char b[] = "dadada";
char c[] = "wererq";

char *p[3];
p[0] = a;
p[1] = b;
p[2] = c;

for(int i = 0; i < 3; ++i){
	cout << p[i] << endl;
}

```

指针数组也可以存储二维数组（矩阵）

```C++
int mat[3][4] = {
	{1,2,3,4},
	{5,6,7,8},
	{9,10,11,12}
}

int *pmat[3];
pmat[0] = mat[0];//获取 mat 第一行 的首地址
pmat[1] = mat[1];//获取 mat 第二行 的首地址
pmat[2] = mat[2];//或者 mat 第三行 的首地址

for(int i = 0; i < 3; ++i){
	for(int j = 0; j < 4 ; ++j){
		cout << *(pmat[i] + j);//pmat[i] 得到第几行 +j 往后偏移多少 也就是 第几列的元素
	}
}
```
# 数组指针

> 数组 的 指针
> 用来存储数组 的 指针

如果是二维数组，那么请确保二维数组的列 与 数组指针 相同

```C++
int (*p)[5];
int a[4][5] = {
	//赋值
};

p = a;//p 将指向 二维数组 a 的首地址(也就是指向了第一行)
p++;//此时进行递增操作，地址将指向第二行
```
# 指针传参

深拷贝

```C++
void swap(int *a,int *b){
	int temp = *a;//解引用
	*a = *b;//进行调换
	*b = *temp;
}

//调用
int a = 10;
int b = 20;
swap(&a,&b);
```
传入参数为 变量的地址
通过解引用来获得指针指向的值
通过指针间接访问和修改调用者提供的原始数据
由于地址相同，函数内部修改后，外部的变量也会进行修改
# 指针函数

```C++
int* func(){

	return NULL;
}
```

一个函数，相要返回一个数组时，可以使用指针函数
只需要返回这个数组的首地址

>  数组名就是数组首地址
# 函数指针

> 指向函数的指针

```C++
double (*prt)(double x,double y,double z);

double func(doudouble x,double y,double z){
	逻辑处理
}

int main(){
	//让指针指向函数
	prt = func;
	prt(3.12,3.25,3.69);
}

```

类似于 Csharp 中的委托，用来装填函数
参数必须匹配
## 类型定义

跟 Csharp 的委托一样，将函数指针定义为一个类型
需要使用的时候，像类和对象一样，创建一个实例化出来

```C++
typeof int (*prt) (int a,int b);

int func(int a,int b){
	//逻辑处理
}

int main(){
	//实例化一个对象，并指向一个函数
	prt prt1 = func;
}
```
## 函数指针数组

```C++
typeof int (*prt[]) (int a,int b);

int func1(int a,int b){
	//逻辑处理
}

int func2(int a,int b){
	//逻辑处理
}

int func3(int a,int b){
	//逻辑处理
}

int main(){
	//实例化一个对象，并指向一个函数
	prt prt1 = {func1, func2, func3};
}
```

> Csharp 一个委托存储多个函数




---
