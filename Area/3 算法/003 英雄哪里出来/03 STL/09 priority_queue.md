---
tags:
  - "#Cpp"
  - "#STL"
created: 2025-04-28
---

---
# 关联知识点

[[10 unordered_set]]

---
# 基础概念

优先队列
每次出队时让优先级高的先出去

> 最大优先队列：值最大的先出去
> 最小优先队列：值最小的先出去

它是一个 ==线性模拟树==

***通过一个数组来表示一个二叉树***
## 数组表示二叉树

数组存储 二叉树的层序遍历 的结果

对于一个元素，知道它在数组内的下标，可以使用 $parent(id) = （id - 1） / 2$ 下取整
来得到它的父结点 id（父结点 id 从 0 开始）
左子树 $left(id) = id \times 2 + 1$
右子树 $right(id) = id \times 2 + 2$
## 堆

完全二叉树上的结点值，都比其左右子树结点的值大或者小

> 大顶堆：结点大于左右子树
> 小顶堆：结点小于左右子树

### 元素插入

- 往数组尾部插入一个元素
	- 注意，此时并没有在树上做任何操作，只是逻辑上构建出一颗树
	- 实际上这颗树的物理结构并没有构建出来，只有一个物理数组
- 对插入的元素，比较它（在树形结构中）和它的父结点的大小关系，来决定是否和父结点进行交换
- 元素插入就是优先队列的入队操作
### 获取堆顶

对于大顶堆来说，就是获取数组中值最大的元素，也就是二叉堆的堆顶，正是堆的根结点

- 获取数组的第 0 个元素
	- 时间复杂度为 $O (1)$
### 元素删除

- 把数组第 0 个元素和最后一个元素交换
- 然后对堆顶的元素不断做”下沉”操作，选择大的进行交换，直到"自己”成为最大的
- 删除数组的最后一个元素
- 元素删除是优先队列的出队操作
# 对象创建

底层是 [[01 vector]]，但模板的第三个参数是一个比较函数
如果不修改，那么默认就是 最大优先队列

```C++
//最大优先队列
priorty_queue<int> q1;
//最小优先队列
priorty_queue<int,vector<int>,greater<int>> q2;
```
# 入队操作

```C++
q1.push(6);
q1.push(3);
```
# 获取堆顶

堆顶一定是一个最值元素

```C++
q1.top();
```
# 出队操作

出队的元素应当是数组的第 0 个元素，也就是 `front`
但 `pop()` 的源码是 `pop_back()`
具体原因：时间复杂度太高
如果使用 `pop_front()` 把首元素出队，那么每次出队都要将剩余的所有元素都往前移动
但是，逻辑上我们把第 0 个元素和最后一个元素进行了交换
所以，本来的 `top()` 就成为数组中最后一个元素了
然后，再执行一次 “下沉” 操作，将首元素放回到正确位置上

```C++
q1.pop();
```
# 大小操作

```C++
empty();//当前是否为空
size();//获取当前元素个数
```
# 自定义操作

```C++
struct type {  
    int key;  
    int value;  
  
    type() { key = value = 0; }  
  
    type(int k, int v) : key(k), value(v) {}  
  
    //重载运算符 否则优先队列无法比较每个元素的大小  
    bool operator<(const type &t) const {  
        //两个const必须添加  
        //第一个防止修改传入的参数  
        //第二个防止成员变量不被修 同时 priority_queue 中的运算符重载函数也为常函数  
        return key < t.key;  
    }  
};  
  
  
int main() {  
  
    priority_queue<type> queue1;  
    queue1.push(type(6, 27));  
    queue1.push(type(5, 331));  
    queue1.push(type(12, 1));  
    queue1.push(type(1, 8));  
    queue1.push(type(9, 5));  
  
    return 0;  
}
```


---
