---
tags:
  - "#Cpp"
  - "#数据结构"
created: 2025-04-20
---

---
# 关联知识点

[[11 邻接表]]

---
# 概念

由于图是由顶点和边 (或弧) 两部分组成的。顶点可以用一个一维的顺序表来存储
但是边 (或弧) 由于是顶点与顶点之间的关系，一维搞不定，所以可以考虑用一个二维的顺序表来存储

而二维的顺序表就是一个矩阵
对于一个有 n 个顶点的图 G，邻接矩阵是一个 $n \times n$ 的方阵 (方阵就是行列数相等的矩阵)

对于邻接矩阵而言，不需要去考虑是有向的还是无向的，统一都可以理解成有向的
因为有向图可以兼容无向图，对于无向图而言，只不过这个矩阵是按照主对角线对称的
因为 A 到 B 有边，则必然 B 到 A 有边

对带权图和无权图，邻接矩阵的表示略有差别
# 无权图的邻接矩阵

对于一个 $n \times n$ 图中，采用一个 $n \times n$ 的方阵 adj[n][n]，在这样一个矩阵里
- 矩阵的行和列都对应图中的一个顶点
- 果顶点 A 到 顶点 B 有一条边 (这里是单向的)，则对应矩阵单元为 1
- 如果顶点 A 到 顶点 B 没有边 (这里同样是单向的)，则对应的矩阵单元就为 0
	- 例如，对于一个有四个顶点的无权图，首先需要有一个顺序表来存储所有的顶点的 (A, B, C, D)

简单解释一下，对于矩阵的主对角线的值 $adj[0][0]、adj[1][1]、adj[2][2]、adj[3][3]$ 全为 0,

因为这个图中，不存在顶点自己到自己的边，$adj[0][1]=1$ 是因为 A 到 B 的边存在，而 $adj[2][0]=0$ 是因为 C 到 A 的边不存在

对于无向图而言，它的邻接矩阵是一个对称矩阵
有了这个矩阵, 就可以很容易地知道图中的信息

- 我们要判定任意两顶点之间是否有边就非常容易
- 我们要知道某个顶点的度，其实就是这个顶点在邻接矩阵中 i 行的元素之和
- 求顶点 i 的所有邻接点就是将矩阵中第 i 行元素扫描一遍，$ard[ij]$ 为 1 就是邻接点
# 带权图的邻接矩阵

在带权图的邻接矩阵中，每个矩阵元素表示一个有向边的权值
如果不存在从一个节点到另一个节点的边，则通常将其表示为特殊的值，如 0，-1 或无穷

假设有一个有向带权图，它有 4 个顶点 (A, B, C, D)，边及其权重如下

- 边 A->B 的权重是 3
- 边 A->C 的权重是 7
- 边 B->A 的权重是 4
- 边 B->D 的权重是 1
- 边 C->D 的权重是 2
- 边 D->A 的权重是 1

可以将这个有向带权图表示为以下的邻接矩阵

```
  A  B  C  D
A 0  3  7  0
B 4  0  0  1
C 0  0  0  2
D 1  0  0  0
```

在这个矩阵中，行表示起始顶点，列表示目标顶点
矩阵元素的值代表起始顶点到目标顶点的边的权重
如果没有边存在，我们用 0 来表示

例如，第一行表示从 A 到各点的边的权重，可以看出有从 A 到 B 的边，权重为 3
有从 A 到 C 的边，权重为 7
没有从 A 出发到达 D 的边，所以为 0

当然，什么情况下不能用 0 来代表边不存在的情况
大多数情况下边权是正值，但个别时候真的有可能就是 0，甚至有可能是负值
因此必须要用个不可能的值来代表不存在
# 邻接矩阵的优点

- 简单直观:
	- 邻接矩阵是一个二维顺序表
		- 通过矩阵中的元素值可以直接表示顶点之间的连接关系，非常直观和易于理解
- 存储效率高
	- 对于小型图，邻接矩阵的存储效率较高，因为它可以一次性存储所有顶点之间的连接关系
		- 不需要额外的空间来存储边的信息
- 算法实现简单
	- 许多图算法可以通过邻接矩阵进行简单而高效的实现
		- 例如 遍历图、检测连通性等
# 邻接矩阵的缺点

- 空间复杂度高
	- 对于大型图，邻接矩阵的空间复杂度较高，因为它需要存储一个 $n \times n$ 的矩阵
	- 这可能导致存储空间的浪费和效率问题
- 不适合稀疏图
	- 邻接矩阵对于稀疏图 (即图中大部分顶点之间没有连接) 的表示效率较低
	- 因为它会浪费大量的存储空间来存储 零元素
# 手写邻接矩阵模板

```C++
#include "iostream"  
  
using namespace std;  
  
#define inf -1 //定义的无穷  
  
//图  
class Graph {  
private:  
    int vertices;//多少个顶点  
    int **edges;//边  
public:  
    Graph(int vertices);  
  
    ~Graph();  
  
    void addEdge(int u, int v, int w);//增加一条边  
  
    void printGraph();//打印图  
};  
  
  
Graph::Graph(int vertices) {  
    //初始化一个图  
    //得到顶点的个数  
    this->vertices = vertices;  
    //edges 为一个指针数组，也是一个二维数组  
    //数组的元素都是指针，指向一个数组  
    edges = new int *[vertices];  
  
    //遍历数组  
    for (int i = 0; i < vertices; ++i) {  
        //创建数组  
        edges[i] = new int[vertices];  
  
        //遍历创建出来的数组的每一个元素  
        for (int j = 0; j < vertices; ++j) {  
            //赋值为 inf            //代表一开始 任意两个顶点都没有边  
            edges[i][j] = inf;  
        }  
    }  
}  
  
Graph::~Graph() {  
    for (int i = 0; i < vertices; ++i) {  
        //把 edges 内的元素内存清理掉  
        delete[] edges[i];  
    }  
    //把 edges 本身也清理掉  
    delete[] edges;  
}  
  
void Graph::addEdge(int u, int v, int w) {  
    //边 u 到 边 v 权重为 w    edges[u][v] = w;  
}  
  
void Graph::printGraph() {  
    for (int i = 0; i < vertices; ++i) {  
        for (int j = 0; j < vertices; ++j) {  
            cout << edges[i][j] << " ";  
        }  
        cout << endl;  
    }  
}  
  
int main() {  
  
    int vertices = 5;  
    Graph graph(vertices);  
    graph.addEdge(0, 1, 1);  
    graph.addEdge(0, 2, 3);  
    graph.addEdge(1, 2, 2);  
    graph.addEdge(2, 3, 7);  
    graph.addEdge(3, 4, 9);  
    graph.addEdge(4, 0, 4);  
    graph.addEdge(4, 2, 5);  
    graph.printGraph();  
  
    return 0;  
}
```

---
